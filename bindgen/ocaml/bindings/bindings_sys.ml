(* automatically generated by ocaml-bindgen 0.0.1 *)

type lifetime =
  | Function
      (** The value can live for the lifetime of the function call, which upon return will signal that the 
                value can be dropped (finalizer?) *)
  | Ocaml  (** The value is managed by the OCaml runtime *)
  | C
      (** The value is allocated and passed to C which is then in charge of cleaning it up *)

type 'a cptr = { lifetime : lifetime; addr : nativeint }

external bindgen_alloc : size:int -> nativeint = "bindgen_alloc"
external bindgen_free : nativeint -> unit = "bindgen_free"
external bindgen_alloc_string : string -> nativeint = "bindgen_alloc_string"

let sizeof _ = 4 (* TODO: how to handle different types? *)

let create_ptr (value : 'a) : 'a cptr =
  let addr = bindgen_alloc ~size:(sizeof value) in
  print_endline ("Addr: " ^ Nativeint.to_string addr);
  Gc.finalise bindgen_free addr;
  { lifetime = Ocaml; addr }

let make_cstr (s: string) : char cptr =
  let addr = bindgen_alloc_string s in
  { lifetime = Ocaml; addr }
  
type nonrec core
type nonrec glfwwindow
external get_global_core : unit -> core cptr = "caml_get_global_core"
external core_Bringup :
  optional_window:unit cptr -> unit = "caml_core_Bringup"
external frame_Begin : unit -> unit = "caml_frame_Begin"
external frame_Draw : unit -> unit = "caml_frame_Draw"
external frame_End : unit -> unit = "caml_frame_End"
type nonrec vec2 = {
  x: float ;
  y: float }
type nonrec vec3 = {
  x: float ;
  y: float ;
  z: float }
type nonrec vec4 = {
  x: float ;
  y: float ;
  z: float ;
  w: float }
external vec3_add : b:vec3 -> a:vec3 -> vec3 = "caml_vec3_add"
