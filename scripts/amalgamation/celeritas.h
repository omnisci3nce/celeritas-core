void GPU_Renderpass_Destroy(GPU_Renderpass* pass);
void GraphicsPipeline_Destroy(GPU_Pipeline* pipeline);
GPU_CmdEncoder GPU_CmdEncoder_Create();
void GPU_CmdEncoder_Destroy(GPU_CmdEncoder* encoder);
void GPU_CmdEncoder_Begin(GPU_CmdEncoder* encoder);
void GPU_CmdEncoder_Finish(GPU_CmdEncoder* encoder);
void GPU_CmdEncoder_BeginRender(GPU_CmdEncoder* encoder, GPU_Renderpass* renderpass);
void GPU_CmdEncoder_EndRender(GPU_CmdEncoder* encoder);
void GPU_QueueSubmit(GPU_CmdBuffer* cmd_buffer);
void GPU_BufferDestroy(BufferHandle handle);
void GPU_BufferUpload(BufferHandle buffer, size_t n_bytes, const void* data);
TextureHandle GPU_TextureCreate(TextureDesc desc, bool create_view, const void* data);
void GPU_TextureDestroy(TextureHandle handle);
void GPU_TextureUpload(TextureHandle handle, size_t n_bytes, const void* data);
void GPU_EncodeBindPipeline(GPU_CmdEncoder* encoder, GPU_Pipeline* pipeline);
void GPU_EncodeBindShaderData(GPU_CmdEncoder* encoder, u32 group, ShaderData data);
void GPU_EncodeSetVertexBuffer(GPU_CmdEncoder* encoder, BufferHandle buf);
void GPU_EncodeSetIndexBuffer(GPU_CmdEncoder* encoder, BufferHandle buf);
void GPU_EncodeDraw(GPU_CmdEncoder* encoder, u64 count);
void GPU_EncodeDrawIndexed(GPU_CmdEncoder* encoder, u64 index_count);
bool GPU_Backend_BeginFrame();
void GPU_Backend_EndFrame();
Skybox Skybox_Create(const char** face_paths, int n);
void Skybox_Draw(Skybox* skybox, Camera camera);
void SetCamera(Camera camera);
void SetMainLight(DirectionalLight light);
void PBR_Init(PBR_Storage* storage);
void Shadow_Init(Shadow_Storage* storage, u32 shadowmap_width, u32 shadowmap_height);
void Shadow_Run(RenderEnt* entities, size_t entity_count);
void Shadow_DrawDebugQuad();
TextureHandle Shadow_GetShadowMapTexture(Shadow_Storage* storage);
void Immdraw_Init(Immdraw_Storage* storage);
void Immdraw_Shutdown(Immdraw_Storage* storage);
void Immdraw_Plane(Transform tf, Vec4 colour, bool wireframe);
void Immdraw_Cuboid(Transform tf, Vec4 colour, bool wireframe);
void Immdraw_Sphere(Transform tf, f32 size, Vec4 colour, bool wireframe);
void Immdraw_TransformGizmo(Transform tf, f32 size);
void EncodeDrawModel(Handle model, Mat4 transform);
void EncodeDrawMesh(Mesh* mesh, Material* material, Mat4 affine);
bool Renderer_Init(RendererConfig config, Renderer* renderer, GLFWwindow** out_window);
void Renderer_Shutdown(Renderer* renderer);
size_t Renderer_GetMemReqs();
void Render_FrameBegin(Renderer* renderer);
void Render_FrameEnd(Renderer* renderer);
void Render_RenderEntities(RenderEnt* entities, size_t entity_count);
TextureData TextureDataLoad(const char* path, bool invert_y);
void TextureUpload(TextureHandle handle, size_t n_bytes, const void* data);
TextureHandle TextureLoadFromFile(const char* path);
ModelHandle ModelLoad(const char* debug_name, const char* filepath);
Mesh Mesh_Create(Geometry* geometry, bool free_on_upload);
void Mesh_Delete(Mesh* mesh);
void DrawMesh(Mesh* mesh, Material* material, Mat4 model);
void Render_DrawTerrain();
static inline Vec3 vec3_create(f32 x, f32 y, f32 z);
